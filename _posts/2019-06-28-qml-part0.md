---
layout: left
title: PyQGIS, QML and charts
active: Articles
---

# PyQGIS, QML and charts

<hr>
{:.post-icon}
![date]({{ site.baseurl }}/images/posts/calendar.png){:width="18px"} &emsp; *2019/06/28*

{:.post-icon}
![tags]({{ site.baseurl }}/images/posts/tag.png){:width="18px"} &emsp; *QGIS, Python, QML, Charts*

{:.post-icon}
![avatar]({{ site.baseurl }}/images/posts/avatar.png){:width="18px"} &emsp; *Paul Blottiere*
<hr>

## Introduction

A recurring question when developing a QGIS Python Plugin is the kind of
existing tools or libraries to plot a graph, and actually, there is no single
solution.  First, let's take a quick look on the different options.

The most common solution is to use the famous
<a href="https://matplotlib.org/">matplotlib</a> library. There are
many articles available online on this subject. Indeed, it's a robust solution
with a huge amount of documentation.

Another very interesting solution is the
<a href="https://plot.ly/python/">Plotly</a> library, which allows to make high
quality graphs with an emphasis on interactivity. By the way,
<a href="https://github.com/ghtmtt/DataPlotly">DataPlotly</a> is an
awesome QGIS plugin written by Matteo Ghetta which uses Plotly and allows to
explore your data thanks to numerous plot types.

A third solution is <a href="http://pygal.org/en/stable/">Pygal</a>, a simple
but still efficient Python library allowing to draw and export SVG graphics.
Interactivity is limited, but still sufficient for numerous cases. For example,
<a href="https://github.com/pblottiere/graffiti">graffiti</a> uses this library
to generate statistics reports on QGIS Server performances.

A clear disadvantage of all these solutions is the need of an external library,
requiring the installation of a package. It's not a big issue, but the
ability to draw good quality charts without external dependencies within QGIS
is still a real question. By the way, a
<a href="https://github.com/qgis/QGIS-Enhancement-Proposals/issues/34">QEP</a>
is currently in progress on this subject. And on this occasion, Hugo Mercier
recently brought up the possibility to directly use the QGIS core symbology to
plot charts, just like what was done for the
<a href="https://github.com/Oslandia/QGeoloGIS">QGeoloGIS</a> plugin.

But in this article, we'll take a look to a completely different solution: the
Qt QML module. Actually, this module provides a dedicated API to design and
display many different kinds of
<a href="https://doc.qt.io/qt-5/qtcharts-qmlmodule.html">chart types</a>. Not
only this solution allows to plot high quality graphs with a compelling
interactivity, but it's directly distributed with Qt!

From now on, we're going to focus on ways to use the QML chart API in QGIS
Python plugins. Source code provided in this article is available on github and
can been tested in the
<a href="https://docs.qgis.org/3.4/it/docs/user_manual/plugins/python_console.html">code editor</a>
embedded with QGIS.

Source code has been tested on GNU/Linux (Archlinux) with QGIS master and on
Windows 10 with QGIS 3.8.  On Windows, QGIS was installed with the standalone
installer and no additional packages was needed to use the QML API.  On
Archlinux, I had to install the `qt5-charts`{:.inline} package.
<hr>

## QML loading

Our first goal is to display a simple pie chart. To do that, we create a QML
file `/tmp/pie.qml`{:.inline} with a `ChartView`{:.inline} containing a
`PieSeries`{:.inline} with some slices. The chart is slightly customised
(title, background color, ...) but much more can be done.

```qml
import QtCharts 2.0
import QtQuick 2.0

ChartView {
  antialiasing: true
  title: "Chart Title"
  titleColor: "white"
  backgroundColor: "#404040"
  legend.labelColor: "white"

  PieSeries {
    PieSlice { label: "Slice0"; value: 70.0 }
    PieSlice { label: "Slice1"; value: 15.5 }
    PieSlice { label: "Slice2"; value: 14.5 }
  }
}
```

<br/>
Then, we can use the `QQuickView`{:.inline} Python class with the
`setSource`{:.inline} method to effectively load the QML file:

```python
from qgis.PyQt.QtCore import QUrl
from PyQt5.QtQuick import QQuickView

qml = "/tmp/pie.qml"

view = QQuickView()
view.setResizeMode(QQuickView.SizeRootObjectToView)
view.setSource(QUrl.fromLocalFile(qml))
view.setColor(QColor("#404040"))
view.show()
````

<br/>
![Pie Chart]({{ site.baseurl }}/images/posts/qml-part0/pie.png){:class="center-image" width="400px"}
<br/>

In the previous example, a dedicated window is used to display the chart after
calling `show()`{:.inline} because `QChartView`{:.inline} inherrits from
`QWindow`{:.inline}. So, we have to create a container allowing to embed a
window into a `QWidget`{:.inline} if we want to display the chart within
another widget, thanks to the `QWidget::createWindowContainer`{:.inline} static
method.

This way, we have to create such a container if we want to add our chart view
within a QGIS dock widget:

```` python
from qgis.PyQt.QtWidgets import QWidget, QDockWidget
from qgis.PyQt.QtCore import Qt

# view.show()
container = QWidget.createWindowContainer(view)

widget = QDockWidget()
widget.setWidget(container)

iface.addDockWidget(Qt.LeftDockWidgetArea, widget)
````

<br/>
![docked]({{ site.baseurl }}/images/posts/qml-part0/qgis.png){:class="center-image" width="600px"}
<br/>

By the way, note that the `status()`{:.inline} method may be used to check for errors:

```python
if view.status() == QQuickView.Error:
    for error in view.errors():
        print(error.description())
````
<hr>

## Configure QML items from Python

In the above example, the pie chart was directly configured in the QML file,
but now, we want to customise the item from a Python script. There are several
ways of doing that, so we are going to address the easiest solution.

Specifically, let's consider the next QML file:

```qml
import QtCharts 2.0
import QtQuick 2.0

ChartView {
  title: pypie.title

  PieSeries {
    id: pieChartId
  }

  Component.onCompleted: {
    initSlices()
  }

  function initSlices() {
    var slices = pypie.slices
    for (var name in slices) {
      pieChartId.append(name, slices[name])
    }
  }
}
```

<br/>
The `Component.onCompleted()`{:.inline} handler is called once the QML item has
been instanciated. In our case, we want to init slices once the pie chart is
ready, so we call the `initSlices()`{:.inline} function where slices are
effectively retrieved thanks to the `pypie.slices`{:.inline} call. The
`pypie`{:.inline} variable is actually a `QObject`{:.inline} coming from
Python. The same object is used to define the chart title.  We may note that
the `PieSeries`{:.inline} id is used to add slices in the chart with
`pieChartId.append`{:.inline} method.

Now, let's define the `QObject`{:.inline} aiming at defining the
`pypie`{:.inline} property:

```` python
class PyPie(QObject):

    titleUpdated = QtCore.pyqtSignal(str)

    def __init__(self):
      super(PyPie, self).__init__()
      self._title = "Chart Title"
      self._slices = { "Slice0": 70.0, "Slice1": 15.5, "Slice2": 14.5}

    @QtCore.pyqtProperty(str, notify=titleUpdated)
    def title(self):
        return self._title

    @title.setter
    def title(self, title):
        if self._title != title:
            self._title = title
            self.titleUpdated.emit(self._title)

    @QtCore.pyqtProperty('QVariantMap')
    def slices(self):
        return self._slices
````

<br/>
The `PyPie`{:.inline} class defines in particular the `title`{:.inline}
property thanks to the decorator `pyqtProperty`{:.inline} allowing the QML item
to retrieve the title thanks to `pypie.title`. An interesting thing to note is
the `notify`{:.inline} parameter used in the decorator. Actually, it means that
as soon as the signal `titleUpdated`{:.inline} is emitted, the property of the
QML item will be automatically updated.  Note that the `slices`{:.inline}
method is also defined as a property to be able to call `pypie.slices` in the
QML file.

Finally, the last necessary step is to "link" the `pypie`{:.inline} property
with a `PyPie`{:.inline} instance. To do that, we have to use
`setContextProperty()`{:.inline} method on the view's context:

```` python
qml = "/tmp/pie.qml"

pypie = PyPie()

view = QQuickView()
view.setResizeMode(QQuickView.SizeRootObjectToView)
view.rootContext().setContextProperty("pypie", pypie)
view.setSource(QUrl.fromLocalFile(qml))
````

<hr>
## Pie chart and categorized renderer

For a more concrete example, consider the following vector layer based on Open
Data [0] where the SU_M2_2014 field, indicating the solar installation surface
in Brittany, is used to define a Rule based renderer:

<br/>
![docked]({{ site.baseurl }}/images/posts/qml-part0/renderer.png){:class="center-image" width="600px"}
<br/>

This way, if we want to display a pie chart based on the proportion of each
rule with the corresponding color, we have to modify the `PyPie`{:.inline}
class:

```` python
from PyQt5.QtQuick import QQuickView
import collections

class PyPie(QObject):

    updated = QtCore.pyqtSignal()

    def __init__(self):
        super(PyPie, self).__init__()
        self._layer = iface.activeLayer()
        self._slices = {}
        self.initSlices()

    def initSlices(self):
        slices = {}
        total_count = self._layer.featureCount()

        renderer = self._layer.renderer()
        for item in renderer.legendSymbolItems():
            if not renderer.legendSymbolItemChecked( item.ruleKey() ):
                continue

            count = self._layer.featureCount(item.ruleKey())
            slices[item.label()] = count * 100 / total_count

        self._slices = slices

    @QtCore.pyqtSlot(str, result='QColor')
    def labelColor(self, label):
        renderer = self._layer.renderer()

        for item in renderer.legendSymbolItems():
            if item.label() != label:
                continue

            return item.symbol().color()

        return QColor()

    @QtCore.pyqtProperty(str)
    def title(self):
        return self._layer.name()

    @QtCore.pyqtProperty('QVariantMap')
    def slices(self):
        return self._slices
````

<br/>
Moreover, in order to retrieve slice's color thanks to rule's label and have
slices ordered by value, we have to sort the object directly in QML:

```qml
import QtCharts 2.0
import QtQuick 2.0

ChartView {
  title: pypie.title

  PieSeries {
    id: pieChartId
  }

  Component.onCompleted: {
    initSlices()
  }

  function sortValues(obj)
  {
    var array=[];

    for(var key in obj) {
      if(obj.hasOwnProperty(key)) {
        array.push([key, obj[key]]);
      }
    }

    array.sort(function(a, b) {
      return b[1]-a[1];
    });

    return array;
  }

  function initSlices() {
    pieChart.clear()
    const sorted = sortValues(pypie.slices)
    const slices = {};
    sorted.forEach(([key, value]) => slices[key] = value);

    for (var name in slices) {
      var slice = pieChart.append(name, slices[name]);
      slice.color = pypie.labelColor(name);
    }
  }
}
```

<br/>

Once the `PyPie.title(self)`{:.inline} method updated to return the active
layer name, we have somehting like this:

<br/>
![docked]({{ site.baseurl }}/images/posts/qml-part0/qgis2.png){:class="center-image" width="600px"}
<br/>

<hr>

## Notify events from Python to QML items

Que se passe t-il si on supprime des objets de notre couche? Il faut notifier l'item QML que les slices ont été modifié pour ordonner un redraw. Pour ça, on utilise notify:

TODO: demo en gif
<hr>

## Catch events from QML items

TODO
<hr>

## Conclusion

TODO

## References

[0] https://www.data.gouv.fr/fr/datasets/surface-des-installations-solaires-thermiques-par-commune-en-bretagne/
